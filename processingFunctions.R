
# File:			processingFunctions.R
#	Author:		Brett Amdur
#	Project:	Measuring Ranking System Performance
# Notes:		This functions in this file take core dataframe created by rankings.R 
#						and perform calculations on it, as described in comments to each function.
#						Also includes code for some plots.


library(ggplot2)
library(dplyr)
library(reshape2)
library(scales)

perfectValues <- function(limitno){
# Creates perfect (1 or 0) y values for each head to head matchup.
# Returns a list of vectors, one vector for each ranking up to limitno
	pLineList <- list()
	for(i in 1:limitno){
		pvect <- as.integer(vector())
		for(j in 1:limitno){
			ifelse(i == j, pvect[j] <- NA, 
			       ifelse(i < j, pvect[j] <- 1, 
			              pvect[j] <- 0))
		}
		pLineList[[i]] <- pvect
	}
	return(pLineList)
}

perfectReg <- function(pValues){
# takes a list of perfect value vectors created by perfectValues(), and returns a list
# of regression models, one for each vector
	pRegList <- list()
	for(i in 1:length(pValues)){
		pReg <- NULL 	# each element in pRegList will be a regression model fit (called pReg)
				# to a set of perfect values.
		#perfHold <- cbind(pValues[[i]], 1:length(pValues))
		perfHold <- data.frame(x = 1:length(pValues), y = pValues[[i]])
		fit <- lm(y ~ x, data = perfHold)
		pRegList[[i]] <- fit
	}
	return(pRegList)
}

makePredictions <- function(perfModels, perfActual, plotStartRank, plotStopRank){
# takes in list of perfect models generated by perfectReg, and returns
# four dataframes: 1) y_perfect (the actual value the model 
# predicts), 2) y_hat (the adjusted y value that puts all y values between 0 and 1)
# 3) the actuals (just returning what was sent in, w/out modification), and 4) the residuals.
# Each data frame is of dimension n x n, where n is limitno.  Also returns, in the list,
# 
	
	#### y_perfect ####
	predictGrid <- data.frame()
	newdf <- data.frame(x = c(plotStartRank:plotStopRank)) # the x values to use in prediction model
	for(i in plotStartRank:plotStopRank){
		predictGrid <- rbind(predictGrid, predict(perfModels[[i]], newdf))
	}
	names(predictGrid) <- as.character(c(plotStartRank:plotStopRank))
	predictGrid$rank <- c(plotStartRank:plotStopRank) # add a column for player rank
	predictGrid <- predictGrid[, c(ncol(predictGrid), 1:ncol(predictGrid)-1)] # move the player rank column to beginning

	#### y_hat ####
	y_hatGrid <- predictGrid
	y_hatGrid[y_hatGrid < 0] <- 0
	y_hatGrid[y_hatGrid > 1] <- 1
	y_hatGrid <- y_hatGrid[, -1] # get rid of the rank column, which we just made inaccurate with the 0/1 replacement
	y_hatGrid$rank <- c(1:length(y_hatGrid)) # add a column for player rank
	y_hatGrid <- y_hatGrid[, c(ncol(y_hatGrid), 1:ncol(y_hatGrid)-1)] # move the player rank column to beginning
	
	### residuals ####
	actValues <- perfActual[[1]]
	resids <- apply(actValues, 2, FUN = function(x) as.numeric(x)) - as.matrix(y_hatGrid[, -1]) #it's ugly, but it works
	resids <- as.data.frame(data.matrix(resids)) # convert it to df with numerical columns
	resids$rank <- c(1:length(resids)) # add a column for player rank
	resids <- resids[, c(ncol(resids), 1:ncol(resids)-1)] # move the player rank column to beginning
	
	### MSE ###
	# calculate root mean squared error for the resids
	mse <- resids[, -1] ^ 2 # square the resids
	mse <- apply(mse, 1, function(x) sum(x, na.rm = TRUE)) # sum the rows
	mse <- sum(mse) / ((length(mse) ^ 2) - length(mse)) # sum the row sums and divde by number of points
			   				   # formula accounts for the nas
	rmse <- sqrt(mse)
	
	### MAD ### 
	# calculate mean absolute deviation of the resids
	absResids <- abs(resids[, -1]) # get rid of the rank column
	points <- (nrow(absResids) ^ 2) - nrow(absResids)
	mad <- sum(apply(absResids, 1, function(x) sum(x, na.rm = TRUE))) / points
	
	### actual values ####
	actValuesGrid <- as.data.frame(data.matrix(actValues)) # convert it to df with numerical columns
	actValuesGrid$rank <- c(1:length(actValuesGrid)) # add a column for player rank
	actValuesGrid <- actValuesGrid[, c(ncol(actValuesGrid), 1:ncol(actValuesGrid)-1)] # move the player rank column to beginning
	
	return(list(predictGrid = predictGrid, 
		    y_hatGrid = y_hatGrid, 
		    actValuesGrid = actValuesGrid, 
		    residsGrid = resids, 
		    rmse = rmse,
		    mad = mad))
}

# plot one of the four grids created by makePredictions
plotGrid <- function(grid){
	meltedValuesdf <- melt(grid, id = "rank")	
	cc <- scales::seq_gradient_pal("yellow", "black", "Lab")(seq(0,1,length.out=length(unique(meltedValuesdf$variable))))
	# note that aes call has the x,y, and group as it does to plot the rows of the grid, rather than
	# the columns.
	myPlot <- ggplot(meltedValuesdf, aes(x=variable, y = value, color = as.factor(rank))) + 
			#geom_jitter(size = 10, alpha = .6, width = 0, height = .05) + 
			geom_point(size = 10) +
			geom_line(aes(group = as.factor(rank))) + 
			scale_colour_manual(values = cc, name = 'Player\nRank') +
			# scale_x_discrete() + scale_y_continuous(limits = c(0,1)) +
			theme_classic() +
			xlab("Opponent Rank") +
			ylab("Win Percentage") +
			theme(axis.title = element_text(size = 30),
					axis.text = element_text(size = 22),
					legend.title = element_text(size = 30),
					legend.text = element_text(size = 22)
		)
	return(myPlot)
}

plotWinPct <- function(limitno, plotStartRank, plotStopRank, winsDF, freqDF, minfreq){
# plot the graph of winning percentage by player rank for all matches
	pal <- colorRampPalette(c("yellow", "black"))
	colors <- pal(limitno)
	plot(x = 1:limitno, ylim=c(0,1), type="n", las = 1,
			 xlab="Opponent's Rank", ylab="Win Percentage")
	
	for(i in plotStartRank:plotStopRank){ # each i is a row / winner ranking
		for(j in 1:limitno){ # each j is a value in the row (i.e. a win pct against another ranking)
			
			if(is.na(as.numeric(winsDF[i,j])) == FALSE & freqDF[i,j] > minfreq){
				points(jitter(j, 2), winsDF[i,j], pch=19, col=alpha(colors[i], 0.6), cex=2.8)
			}
		}
		
	}
}


#### PLOT SHOWING STEP FUNCTION CONVERTED TO REGRESSION LINES ####
z <- as.data.frame(do.call(rbind, perfectValues(20))) # pass number of points desired to perfectValues
z <- cbind(z, c(1:20))
names(z) <- c(names(z)[1:20], 'rank')
z <- z[z$rank %in% c(1, 5, 10, 15, 20), ]
names(z)[1:20] <- as.numeric(c(1:20))
zmelt <- melt(z, id = 'rank')
zmelt$rank <- as.factor(zmelt$rank)
zmelt$variable <- as.numeric(zmelt$variable)
names(zmelt) <- c('PlayerRank', 'OpponentRank', 'WinPercentage')
zmeltOrig <- zmelt

# Manually adjust position of win percentages to make plot look better than jittering 
zmelt[zmelt$PlayerRank == 10 & zmelt$WinPercentage == 1 & ! zmelt$OpponentRank == 10, 3] <- 0.8
zmelt[zmelt$PlayerRank == 5 & zmelt$WinPercentage == 1 & ! zmelt$OpponentRank == 5, 3] <- 0.9
zmelt[zmelt$PlayerRank == 15 & zmelt$WinPercentage == 1 & ! zmelt$OpponentRank == 15, 3] <- 1.1
zmelt[zmelt$PlayerRank == 20 & zmelt$WinPercentage == 1 & ! zmelt$OpponentRank == 20, 3] <- 1.2

zmelt[zmelt$PlayerRank == 1 & zmelt$WinPercentage == 0 & ! zmelt$OpponentRank == 1, 3] <- -0.2
zmelt[zmelt$PlayerRank == 5 & zmelt$WinPercentage == 0 & ! zmelt$OpponentRank == 5, 3] <- -0.1
zmelt[zmelt$PlayerRank == 15 & zmelt$WinPercentage == 0 & ! zmelt$OpponentRank == 15, 3] <- 0.1
zmelt[zmelt$PlayerRank == 10 & zmelt$WinPercentage == 0 & ! zmelt$OpponentRank == 10, 3] <- 0.2

g <- ggplot(zmelt, aes(OpponentRank, WinPercentage, color = PlayerRank)) +
			#geom_jitter(size = 10, width = .5, height = .5) +
			geom_point(size = 10) +
			geom_smooth(data = zmeltOrig, method = lm, se=FALSE, size = 3) +
			scale_y_continuous(labels=percent) +
			scale_x_continuous(breaks=seq(0,20,1)) +
			scale_color_discrete(name="Player\nRank") +
			xlab("Opponent Rank") +
			ylab("Win Percentage") +
			theme_classic() +
			theme(axis.title = element_text(size = 30),
						axis.text = element_text(size = 22),
						legend.title = element_text(size = 30),
						legend.text = element_text(size = 22)
						)
g
#########################################################

